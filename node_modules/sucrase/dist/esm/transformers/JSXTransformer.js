


import XHTMLEntities from "../parser/plugins/jsx/xhtml";
import {JSXRole} from "../parser/tokenizer";
import {TokenType as tt} from "../parser/tokenizer/types";
import {charCodes} from "../parser/util/charcodes";

import getJSXPragmaInfo, {} from "../util/getJSXPragmaInfo";

import Transformer from "./Transformer";

export default class JSXTransformer extends Transformer {
  
  
  

  // State for calculating the line number of each JSX tag in development.
  __init() {this.lastLineNumber = 1}
  __init2() {this.lastIndex = 0}

  // In development, variable name holding the name of the current file.
  __init3() {this.filenameVarName = null}
  // Mapping of claimed names for imports in the automatic transform, e,g.
  // {jsx: "_jsx"}. This determines which imports to generate in the prefix.
  __init4() {this.esmAutomaticImportNameResolutions = {}}
  // When automatically adding imports in CJS mode, we store the variable name
  // holding the imported CJS module so we can require it in the prefix.
  __init5() {this.cjsAutomaticModuleNameResolutions = {}}

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     options,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.options = options;JSXTransformer.prototype.__init.call(this);JSXTransformer.prototype.__init2.call(this);JSXTransformer.prototype.__init3.call(this);JSXTransformer.prototype.__init4.call(this);JSXTransformer.prototype.__init5.call(this);;
    this.jsxPragmaInfo = getJSXPragmaInfo(options);
    this.isAutomaticRuntime = options.jsxRuntime === "automatic";
    this.jsxImportSource = options.jsxImportSource || "react";
  }

  process() {
    if (this.tokens.matches1(tt.jsxTagStart)) {
      this.processJSXTag();
      return true;
    }
    return false;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.filenameVarName) {
      prefix += `const ${this.filenameVarName} = ${JSON.stringify(this.options.filePath || "")};`;
    }
    if (this.isAutomaticRuntime) {
      if (this.importProcessor) {
        // CJS mode: emit require statements for all modules that were referenced.
        for (const [path, resolvedName] of Object.entries(this.cjsAutomaticModuleNameResolutions)) {
          prefix += `var ${resolvedName} = require("${path}");`;
        }
      } else {
        // ESM mode: consolidate and emit import statements for referenced names.
        const {createElement: createElementResolution, ...otherResolutions} =
          this.esmAutomaticImportNameResolutions;
        if (createElementResolution) {
          prefix += `import {createElement as ${createElementResolution}} from "${this.jsxImportSource}";`;
        }
        const importSpecifiers = Object.entries(otherResolutions)
          .map(([name, resolvedName]) => `${name} as ${resolvedName}`)
          .join(", ");
        if (importSpecifiers) {
          const importPath =
            this.jsxImportSource + (this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime");
          prefix += `import {${importSpecifiers}} from "${importPath}";`;
        }
      }
    }
    return prefix;
  }

  processJSXTag() {
    const {jsxRole, start} = this.tokens.currentToken();
    // Calculate line number information at the very start (if in development
    // mode) so that the information is guaranteed to be queried in token order.
    const elementLocationCode = this.options.production ? null : this.getElementLocationCode(start);
    if (this.isAutomaticRuntime && jsxRole !== JSXRole.KeyAfterPropSpread) {
      this.transformTagToJSXFunc(elementLocationCode, jsxRole);
    } else {
      this.transformTagToCreateElement(elementLocationCode);
    }
  }

  getElementLocationCode(firstTokenStart) {
    const lineNumber = this.getLineNumberForIndex(firstTokenStart);
    return `lineNumber: ${lineNumber}`;
  }

  /**
   * Get the line number for this source position. This is calculated lazily and
   * must be called in increasing order by index.
   */
  getLineNumberForIndex(index) {
    const code = this.tokens.code;
    while (this.lastIndex < index && this.lastIndex < code.length) {
      if (code[this.lastIndex] === "\n") {
        this.lastLineNumber++;
      }
      this.lastIndex++;
    }
    return this.lastLineNumber;
  }

  /**
   * Convert the current JSX element to a call to jsx, jsxs, or jsxDEV. This is
   * the primary transformation for the automatic transform.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * jsxs('div', {a: 1, children: ["Hello", x]}, 2)
   */
  transformTagToJSXFunc(elementLocationCode, jsxRole) {
    const isStatic = jsxRole === JSXRole.StaticChildren;
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getJSXFuncInvocationCode(isStatic));

    let keyCode = null;
    if (this.tokens.matches1(tt.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, {`);
      this.processAutomaticChildrenAndEndProps(jsxRole);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.tokens.appendCode(", {");
      keyCode = this.processProps(true);

      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {
        // Self-closing tag, no children to add, so close the props.
        this.tokens.appendCode("}");
      } else if (this.tokens.matches1(tt.jsxTagEnd)) {
        // Tag with children.
        this.tokens.removeToken();
        this.processAutomaticChildrenAndEndProps(jsxRole);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
      // If a key was present, move it to its own arg. Note that moving code
      // like this will cause line numbers to get out of sync within the JSX
      // element if the key expression has a newline in it. This is unfortunate,
      // but hopefully should be rare.
      if (keyCode) {
        this.tokens.appendCode(`, ${keyCode}`);
      }
    }
    if (!this.options.production) {
      // If the key wasn't already added, add it now so we can correctly set
      // positional args for jsxDEV.
      if (keyCode === null) {
        this.tokens.appendCode(", void 0");
      }
      this.tokens.appendCode(`, ${isStatic}, ${this.getDevSource(elementLocationCode)}, this`);
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(tt.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Convert the current JSX element to a createElement call. In the classic
   * runtime, this is the only case. In the automatic runtime, this is called
   * as a fallback in some situations.
   *
   * Example:
   * <div a={1} key={2}>Hello{x}</div>
   * becomes
   * React.createElement('div', {a: 1, key: 2}, "Hello", x)
   */
  transformTagToCreateElement(elementLocationCode) {
    // First tag is always jsxTagStart.
    this.tokens.replaceToken(this.getCreateElementInvocationCode());

    if (this.tokens.matches1(tt.jsxTagEnd)) {
      // Fragment syntax.
      this.tokens.replaceToken(`${this.getFragmentCode()}, null`);
      this.processChildren(true);
    } else {
      // Normal open tag or self-closing tag.
      this.processTagIntro();
      this.processPropsObjectWithDevInfo(elementLocationCode);

      if (this.tokens.matches2(tt.slash, tt.jsxTagEnd)) {
        // Self-closing tag; no children to process.
      } else if (this.tokens.matches1(tt.jsxTagEnd)) {
        // Tag with children and a close-tag; process the children as args.
        this.tokens.removeToken();
        this.processChildren(true);
      } else {
        throw new Error("Expected either /> or > at the end of the tag.");
      }
    }
    // We're at the close-tag or the end of a self-closing tag, so remove
    // everything else and close the function call.
    this.tokens.removeInitialToken();
    while (!this.tokens.matches1(tt.jsxTagEnd)) {
      this.tokens.removeToken();
    }
    this.tokens.replaceToken(")");
  }

  /**
   * Get the code for the relevant function for this context: jsx, jsxs,
   * or jsxDEV. The following open-paren is included as well.
   *
   * These functions are only used for the automatic runtime, so they are always
   * auto-imported, but the auto-import will be either CJS or ESM based on the
   * target module format.
   */
  getJSXFuncInvocationCode(isStatic) {
    if (this.options.production) {
      if (isStatic) {
        return this.claimAutoImportedFuncInvocation("jsxs", "/jsx-runtime");
      } else {
        return this.claimAutoImportedFuncInvocation("jsx", "/jsx-runtime");
      }
    } else {
      return this.claimAutoImportedFuncInvocation("jsxDEV", "/jsx-dev-runtime");
    }
  }

  /**
   * Return the code to use for the createElement function, e.g.
   * `React.createElement`, including the following open-paren.
   *
   * This is the main function to use for the classic runtime. For the
   * automatic runtime, this function is used as a fallback function to
   * preserve behavior when there is a prop spread followed by an explicit
   * key. In that automatic runtime case, the function should be automatically
   * imported.
   */
  getCreateElementInvocationCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedFuncInvocation("createElement", "");
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.base) || jsxPragmaInfo.base
        : jsxPragmaInfo.base;
      return `${resolvedPragmaBaseName}${jsxPragmaInfo.suffix}(`;
    }
  }

  /**
   * Return the code to use as the component when compiling a shorthand
   * fragment, e.g. `React.Fragment`.
   *
   * This may be called from either the classic or automatic runtime, and
   * the value should be auto-imported for the automatic runtime.
   */
  getFragmentCode() {
    if (this.isAutomaticRuntime) {
      return this.claimAutoImportedName(
        "Fragment",
        this.options.production ? "/jsx-runtime" : "/jsx-dev-runtime",
      );
    } else {
      const {jsxPragmaInfo} = this;
      const resolvedFragmentPragmaBaseName = this.importProcessor
        ? this.importProcessor.getIdentifierReplacement(jsxPragmaInfo.fragmentBase) ||
          jsxPragmaInfo.fragmentBase
        : jsxPragmaInfo.fragmentBase;
      return resolvedFragmentPragmaBaseName + jsxPragmaInfo.fragmentSuffix;
    }
  }

  /**
   * Return code that invokes the given function.
   *
   * When the imports transform is enabled, use the CJSImportTransformer
   * strategy of using `.call(void 0, ...` to avoid passing a `this` value in a
   * situation that would otherwise look like a method call.
   */
  claimAutoImportedFuncInvocation(funcName, importPathSuffix) {
    const funcCode = this.claimAutoImportedName(funcName, importPathSuffix);
    if (this.importProcessor) {
      return `${funcCode}.call(void 0, `;
    } else {
      return `${funcCode}(`;
    }
  }

  claimAutoImportedName(funcName, importPathSuffix) {
    if (this.importProcessor) {
      // CJS mode: claim a name for the module and mark it for import.
      const path = this.jsxImportSource + importPathSuffix;
      if (!this.cjsAutomaticModuleNameResolutions[path]) {
        this.cjsAutomaticModuleNameResolutions[path] =
          this.importProcessor.getFreeIdentifierForPath(path);
      }
      return `${this.cjsAutomaticModuleNameResolutions[path]}.${funcName}`;
    } else {
      // ESM mode: claim a name for this function and add it to the names that
      // should be auto-imported when the prefix is generated.
      if (!this.esmAutomaticImportNameResolutions[funcName]) {
        this.esmAutomaticImportNameResolutions[funcName] = this.nameManager.claimFreeName(
          `_${funcName}`,
        );
      }
      return this.esmAutomaticImportNameResolutions[funcName];
    }
  }

  /**
   * Process the first part of a tag, before any props.
   */
  processTagIntro() {
    // Walk forward until we see one of these patterns:
    // jsxName to start the first prop, preceded by another jsxName to end the tag name.
    // jsxName to start the first prop, preceded by greaterThan to end the type argument.
    // [open brace] to start the first prop.
    // [jsxTagEnd] to end the open-tag.
    // [slash, jsxTagEnd] to end the self-closing tag.
    let introEnd = this.tokens.currentIndex() + 1;
    while (
      this.tokens.tokens[introEnd].isType ||
      (!this.tokens.matches2AtIndex(introEnd - 1, tt.jsxName, tt.jsxName) &&
        !this.tokens.matches2AtIndex(introEnd - 1, tt.greaterThan, tt.jsxName) &&
        !this.tokens.matches1AtIndex(introEnd, tt.braceL) &&
        !this.tokens.matches1AtIndex(introEnd, tt.jsxTagEnd) &&
        !this.tokens.matches2AtIndex(introEnd, tt.slash, tt.jsxTagEnd))
    ) {
      introEnd++;
    }
    if (introEnd === this.tokens.currentIndex() + 1) {
      const tagName = this.tokens.identifierName();
      if (startsWithLowerCase(tagName)) {
        this.tokens.replaceToken(`'${tagName}'`);
      }
    }
    while (this.tokens.currentIndex() < introEnd) {
      this.rootTransformer.processToken();
    }
  }

  /**
   * Starting at the beginning of the props, add the props argument to
   * React.createElement, including the comma before it.
   */
  processPropsObjectWithDevInfo(elementLocationCode) {
    const devProps = this.options.production
      ? ""
      : `__self: this, __source: ${this.getDevSource(elementLocationCode)}`;
    if (!this.tokens.matches1(tt.jsxName) && !this.tokens.matches1(tt.braceL)) {
      if (devProps) {
        this.tokens.appendCode(`, {${devProps}}`);
      } else {
        this.tokens.appendCode(`, null`);
      }
      return;
    }
    this.tokens.appendCode(`, {`);
    this.processProps(false);
    if (devProps) {
      this.tokens.appendCode(` ${devProps}}`);
    } else {
      this.tokens.appendCode("}");
    }
  }

  /**
   * Transform the core part of the props, assuming that a { has already been
   * inserted before us and that a } will be inserted after us.
   *
   * If extractKeyCode is true (i.e. when using any jsx... function), any prop
   * named "key" has its code captured and returned rather than being emitted to
   * the output code. This shifts line numbers, and emitting the code later will
   * correct line numbers again. If no key is found or if extractKeyCode is
   * false, this function returns null.
   */
  processProps(extractKeyCode) {
    let keyCode = null;
    while (true) {
      if (this.tokens.matches2(tt.jsxName, tt.eq)) {
        // This is a regular key={value} or key="value" prop.
        const propName = this.tokens.identifierName();
        if (extractKeyCode && propName === "key") {
          if (keyCode !== null) {
            // The props list has multiple keys. Different implementations are
            // inconsistent about what to do here: as of this writing, Babel and
            // swc keep the *last* key and completely remove the rest, while
            // TypeScript uses the *first* key and leaves the others as regular
            // props. The React team collaborated with Babel on the
            // implementation of this behavior, so presumably the Babel behavior
            // is the one to use.
            // Since we won't ever be emitting the previous key code, we need to
            // at least emit its newlines here so that the line numbers match up
            // in the long run.
            this.tokens.appendCode(keyCode.replace(/[^\n]/g, ""));
          }
          // key
          this.tokens.removeToken();
          // =
          this.tokens.removeToken();
          const snapshot = this.tokens.snapshot();
          this.processPropValue();
          keyCode = this.tokens.dangerouslyGetAndRemoveCodeSinceSnapshot(snapshot);
          // Don't add a comma
          continue;
        } else {
          this.processPropName(propName);
          this.tokens.replaceToken(": ");
          this.processPropValue();
        }
      } else if (this.tokens.matches1(tt.jsxName)) {
        // This is a shorthand prop like <input disabled />.
      Locked=qps-ploc,qps-plocm}","ui/appBarIcons/zoom":"","_ui/appBarIcons/zoom.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/zoomout":"","_ui/appBarIcons/zoomout.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/openfile":"","_ui/appBarIcons/openfile.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/otheruser":"","_ui/appBarIcons/otheruser.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/admin":"","_ui/appBarIcons/admin.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/street":"","_ui/appBarIcons/street.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/map":"","_ui/appBarIcons/map.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/clearselection":"","_ui/appBarIcons/clearselection.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/fontdecrease":"","_ui/appBarIcons/fontdecrease.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/fontincrease":"","_ui/appBarIcons/fontincrease.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/fontsize":"","_ui/appBarIcons/fontsize.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/cellphone":"","_ui/appBarIcons/cellphone.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/reshare":"","_ui/appBarIcons/reshare.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/tag":"","_ui/appBarIcons/tag.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/repeatone":"","_ui/appBarIcons/repeatone.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/repeatall":"","_ui/appBarIcons/repeatall.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/outlinestar":"","_ui/appBarIcons/outlinestar.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/solidstar":"","_ui/appBarIcons/solidstar.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/calculator":"","_ui/appBarIcons/calculator.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/directions":"","_ui/appBarIcons/directions.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/target":"","_ui/appBarIcons/target.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/library":"","_ui/appBarIcons/library.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/phonebook":"","_ui/appBarIcons/phonebook.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/memo":"","_ui/appBarIcons/memo.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/microphone":"","_ui/appBarIcons/microphone.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/postupdate":"","_ui/appBarIcons/postupdate.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/backtowindow":"","_ui/appBarIcons/backtowindow.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/fullscreen":"","_ui/appBarIcons/fullscreen.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/newfolder":"","_ui/appBarIcons/newfolder.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/calendarreply":"","_ui/appBarIcons/calendarreply.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/unsyncfolder":"","_ui/appBarIcons/unsyncfolder.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/reporthacked":"","_ui/appBarIcons/reporthacked.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/syncfolder":"","_ui/appBarIcons/syncfolder.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/blockcontact":"","_ui/appBarIcons/blockcontact.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/switchapps":"","_ui/appBarIcons/switchapps.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/addfriend":"","_ui/appBarIcons/addfriend.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/touchpointer":"","_ui/appBarIcons/touchpointer.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/gotostart":"","_ui/appBarIcons/gotostart.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/zerobars":"","_ui/appBarIcons/zerobars.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/onebar":"","_ui/appBarIcons/onebar.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/twobars":"","_ui/appBarIcons/twobars.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/threebars":"","_ui/appBarIcons/threebars.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/fourbars":"","_ui/appBarIcons/fourbars.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/scan":"","_ui/appBarIcons/scan.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/preview":"","_ui/appBarIcons/preview.comment":"{Locked=qps-ploc,qps-plocm}","ui/appBarIcons/hamburger":"","_ui/appBarIcons/hamburger.comment":"{Locked=qps-ploc,qps-plocm}"}),r("WinJS/Core/_Resources",["exports","./_Global","./_WinRT","./_Base","./_Events","require-json!strings/en-us/Microsoft.WinJS.resjson",],function(n,t,i,r,u,f){"use strict";function a(n){var t=c("ms-resource:///Microsoft.WinJS/"+n);return t.empty&&(t=p(n)),t}function p(n){var t=f[n];return typeof t=="string"&&(t={value:t}),t||{value:n,empty:!0}}function l(n){var t=arguments;return t.length>1&&(n=n.replace(/({{)|(}})|{(\d+)}|({)|(})/g,function(n,i,r,u,f,e){if(f||e)throw l(k.malformedFormatStringInput,f||e);return i&&"{"||r&&"}"||t[(u|0)+1]})),n}var e,v=!1,s="contextchanged",h,w=r.Class.mix(r.Class.define(null,{},{supportedForProcessing:!1}),u.eventMixin),o=new w,b=u._createEventProperty,k={get malformedFormatStringInput(){return"Malformed, did you mean to escape your '{0}'?"}},y,c;r.Namespace.define("WinJS.Resources",{_getWinJSString:a});r.Namespace._moduleDefine(n,"WinJS.Resources",{addEventListener:function(t,r,u){if(i.Windows.ApplicationModel.Resources.Core.ResourceManager&&!v&&t===s)try{var f=n._getResourceContext();f?f.qualifierValues.addEventListener("mapchanged",function(t){n.dispatchEvent(s,{qualifier:t.key,changed:t.target[t.key]})},!1):i.Windows.ApplicationModel.Resources.Core.ResourceManager.current.defaultContext.qualifierValues.addEventListener("mapchanged",function(t){n.dispatchEvent(s,{qualifier:t.key,changed:t.target[t.key]})},!1);v=!0}catch(e){}o.addEventListener(t,r,u)},removeEventListener:o.removeEventListener.bind(o),dispatchEvent:o.dispatchEvent.bind(o),_formatString:l,_getStringWinRT:function(t){var f,r,s,u,o;if(!e){f=i.Windows.ApplicationModel.Resources.Core.ResourceManager.current.mainResourceMap;try{e=f.getSubtree("Resources")}catch(h){}e||(e=f)}try{o=n._getResourceContext();u=o?e.getValue(t,o):e.getValue(t);u&&(r=u.valueAsString,r===undefined&&(r=u.toString()))}catch(h){}if(!r)return n._getStringJS(t);try{s=u.getQualifierValue("Language")}catch(h){return{value:r}}return{value:r,lang:s}},_getStringJS:function(n){var i=t.strings&&t.strings[n];return typeof i=="string"&&(i={value:i}),i||{value:n,empty:!0}},_getResourceContext:function(){if(t.document&&typeof h=="undefined"){var n=i.Windows.ApplicationModel.Resources.Core.ResourceContext;h=n.getForCurrentView?n.getForCurrentView():null}return h},oncontextchanged:b(s)});y=i.Windows.ApplicationModel.Resources.Core.ResourceManager?n._getStringWinRT:n._getStringJS;c=function(n){return y(n)};r.Namespace._moduleDefine(n,null,{_formatString:l,_getWinJSString:a});r.Namespace._moduleDefine(n,"WinJS.Resources",{getString:{get:function(){return c},set:function(n){c=n}}})}),r("WinJS/Core/_Trace",["./_Global"],function(n){"use strict";function t(n){return n}return{_traceAsyncOperationStarting:n.Debug&&n.Debug.msTraceAsyncOperationStarting&&n.Debug.msTraceAsyncOperationStarting.bind(n.Debug)||t,_traceAsyncOperationCompleted:n.Debug&&n.Debug.msTraceAsyncOperationCompleted&&n.Debug.msTraceAsyncOperationCompleted.bind(n.Debug)||t,_traceAsyncCallbackStarting:n.Debug&&n.Debug.msTraceAsyncCallbackStarting&&n.Debug.msTraceAsyncCallbackStarting.bind(n.Debug)||t,_traceAsyncCallbackCompleted:n.Debug&&n.Debug.msTraceAsyncCallbackCompleted&&n.Debug.msTraceAsyncCallbackCompleted.bind(n.Debug)||t}}),r("WinJS/Promise/_StateMachine",["../Core/_Global","../Core/_BaseCoreUtils","../Core/_Base","../Core/_ErrorFromName","../Core/_Events","../Core/_Trace"],function(n,t,i,r,u,f){"use strict";function e(){}function g(n,t){var i;i=t&&typeof t=="object"&&typeof t.then=="function"?p:dt;n._value=t;n._setState(i)}function nt(n,t,i,r,u,f){return{exception:n,error:t,promise:i,handler:f,id:r,parent:u}}function tt(n,t,i,r){var u=i._isException,f=i._errorId;return nt(u?t:null,u?null:t,n,f,i,r)}function gt(n,t,i){var r=i._isException,u=i._errorId;return vt(n,u,r),nt(r?t:null,r?null:t,n,u,i)}function ni(n,t){var i=++ht;return vt(n,i),nt(null,t,n,i)}function ti(n,t){var i=++ht;return vt(n,i,!0),nt(t,null,n,i)}function it(n,t,i,r){var u=f._traceAsyncOperationStarting("WinJS.Promise.done");at(n,{c:t,e:i,p:r,asyncOpID:u})}function rt(n,t,i,r){n._value=t;l(n,t,i,r);n._setState(lt)}function ii(t,i){var l=t._value,u=t._listeners,e,s;if(u)for(t._listeners=null,e=0,s=Array.isArray(u)?u.length:1;e<s;e++){var o=s===1?u:u[e],h=o.c,r=o.promise;if(f._traceAsyncOperationCompleted(o.asyncOpID,n.Debug&&n.Debug.MS_ASYNC_OP_STATUS_SUCCESS),r){f._traceAsyncCallbackStarting(o.asyncOpID);try{r._setCompleteValue(h?h(l):l)}catch(a){r._setExceptionValue(a)}finally{f._traceAsyncCallbackCompleted()}r._state!==p&&r._listeners&&i.push(r)}else c.prototype.done.call(t,h)}}function ri(t,i){var u=t._value,e=t._listeners,s,c,v;if(e)for(t._listeners=null,s=0,c=Array.isArray(e)?e.length:1;s<c;s++){var h=c===1?e:e[s],o=h.