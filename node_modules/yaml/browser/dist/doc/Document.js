import { Alias } from '../nodes/Alias.js';
import { isEmptyPath, collectionFromPath } from '../nodes/Collection.js';
import { NODE_TYPE, DOC, isNode, isCollection, isScalar } from '../nodes/identity.js';
import { Pair } from '../nodes/Pair.js';
import { toJS } from '../nodes/toJS.js';
import { Schema } from '../schema/Schema.js';
import { stringifyDocument } from '../stringify/stringifyDocument.js';
import { anchorNames, findNewAnchor, createNodeAnchors } from './anchors.js';
import { applyReviver } from './applyReviver.js';
import { createNode } from './createNode.js';
import { Directives } from './directives.js';

class Document {
    constructor(value, replacer, options) {
        /** A comment before this Document */
        this.commentBefore = null;
        /** A comment immediately after this Document */
        this.comment = null;
        /** Errors encountered during parsing. */
        this.errors = [];
        /** Warnings encountered during parsing. */
        this.warnings = [];
        Object.defineProperty(this, NODE_TYPE, { value: DOC });
        let _replacer = null;
        if (typeof replacer === 'function' || Array.isArray(replacer)) {
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const opt = Object.assign({
            intAsBigInt: false,
            keepSourceTokens: false,
            logLevel: 'warn',
            prettyErrors: true,
            strict: true,
            uniqueKeys: true,
            version: '1.2'
        }, options);
        this.options = opt;
        let { version } = opt;
        if (options?._directives) {
            this.directives = options._directives.atDocument();
            if (this.directives.yaml.explicit)
                version = this.directives.yaml.version;
        }
        else
            this.directives = new Directives({ version });
        this.setSchema(version, options);
        // @ts-expect-error We can't really know that this matches Contents.
        this.contents =
            value === undefined ? null : this.createNode(value, _replacer, options);
    }
    /**
     * Create a deep copy of this Document and its contents.
     *
     * Custom Node values that inherit from `Object` still refer to their original instances.
     */
    clone() {
        const copy = Object.create(Document.prototype, {
            [NODE_TYPE]: { value: DOC }
        });
        copy.commentBefore = this.commentBefore;
        copy.comment = this.comment;
        copy.errors = this.errors.slice();
        copy.warnings = this.warnings.slice();
        copy.options = Object.assign({}, this.options);
        if (this.directives)
            copy.directives = this.directives.clone();
        copy.schema = this.schema.clone();
        // @ts-expect-error We can't really know that this matches Contents.
        copy.contents = isNode(this.contents)
            ? this.contents.clone(copy.schema)
            : this.contents;
        if (this.range)
            copy.range = this.range.slice();
        return copy;
    }
    /** Adds a value to the document. */
    add(value) {
        if (assertCollection(this.contents))
            this.contents.add(value);
    }
    /** Adds a value to the document. */
    addIn(path, value) {
        if (assertCollection(this.contents))
            this.contents.addIn(path, value);
    }
    /**
     * Create a new `Alias` node, ensuring that the target `node` has the required anchor.
     *
     * If `node` already has an anchor, `name` is ignored.
     * Otherwise, the `node.anchor` value will be set to `name`,
     * or if an anchor with that name is already present in the document,
     * `name` will be used as a prefix for a new unique anchor.
     * If `name` is undefined, the generated anchor will use 'a' as a prefix.
     */
    createAlias(node, name) {
        if (!node.anchor) {
            const prev = anchorNames(this);
            node.anchor =
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                !name || prev.has(name) ? findNewAnchor(name || 'a', prev) : name;
        }
        return new Alias(node.anchor);
    }
    createNode(value, replacer, options) {
        let _replacer = undefined;
        if (typeof replacer === 'function') {
            value = replacer.call({ '': value }, '', value);
            _replacer = replacer;
        }
        else if (Array.isArray(replacer)) {
            const keyToStr = (v) => typeof v === 'number' || v instanceof String || v instanceof Number;
            const asStr = replacer.filter(keyToStr).map(String);
            if (asStr.length > 0)
                replacer = replacer.concat(asStr);
            _replacer = replacer;
        }
        else if (options === undefined && replacer) {
            options = replacer;
            replacer = undefined;
        }
        const { aliasDuplicateObjects, anchorPrefix, flow, keepUndefined, onTagObj, tag } = options ?? {};
        const { onAnchor, setAnchors, sourceObjects } = createNodeAnchors(this, 
        // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
        anchorPrefix || 'a');
        const ctx = {
            aliasDuplicateObjects: aliasDuplicateObjects ?? true,
            keepUndefined: keepUndefined ?? false,
            onAnchor,
            onTagObj,
            replacer: _replacer,
            schema: this.schema,
            sourceObjects
        };
        const node = createNode(value, tag, ctx);
        if (flow && isCollection(node))
            node.flow = true;
        setAnchors();
        return node;
    }
    /**
     * Convert a key and a value into a `Pair` using the current schema,
     * recursively wrapping all values as `Scalar` or `Collection` nodes.
     */
    createPair(key, value, options = {}) {
        const k = this.createNode(key, null, options);
        const v = this.createNode(value, null, options);
        return new Pair(k, v);
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    delete(key) {
        return assertCollection(this.contents) ? this.contents.delete(key) : false;
    }
    /**
     * Removes a value from the document.
     * @returns `true` if the item was found and removed.
     */
    deleteIn(path) {
        if (isEmptyPath(path)) {
            if (this.contents == null)
                return false;
            // @ts-expect-error Presumed impossible if Strict extends false
            this.contents = null;
            return true;
        }
        return assertCollection(this.contents)
            ? this.contents.deleteIn(path)
            : false;
    }
    /**
     * Returns item at `key`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    get(key, keepScalar) {
        return isCollection(this.contents)
            ? this.contents.get(key, keepScalar)
            : undefined;
    }
    /**
     * Returns item at `path`, or `undefined` if not found. By default unwraps
     * scalar values from their surrounding node; to disable set `keepScalar` to
     * `true` (collections are always returned intact).
     */
    getIn(path, keepScalar) {
        if (isEmptyPath(path))
            return !keepScalar && isScalar(this.contents)
                ? this.contents.value
                : this.contents;
        return isCollection(this.contents)
            ? this.contents.getIn(path, keepScalar)
            : undefined;
    }
    /**
     * Checks if the document includes a value with the key `key`.
     */
    has(key) {
        return isCollection(this.contents) ? this.contents.has(key) : false;
    }
    /**
     * Checks if the document includes a value at `path`.
     */
    hasIn(path) {
        if (isEmptyPath(path))
            return this.contents !== undefined;
        return isCollection(this.contents) ? this.contents.hasIn(path) : false;
    }
    /**
     * Sen   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   o   c o n   e l   p r o v e e d o r   d e   s e r v i c i o s .   PAS T u   b u z ó n   e s t á   c a s i   l l e n o .   V a c í a   l o s   e l e m e n t o s   e l i m i n a d o s   p a r a   g e n e r a r   m á s   e s p a c i o .   ” T u   d i s p o s i t i v o   n o   a d m i t e   l a s   o p c i o n e s   d e   s e g u r i d a d   q u e   e x i g e   e l   s e r v i d o r .   P o n t e   e n   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   o   c o n   e l   p r o v e e d o r   d e   s e r v i c i o s .   ¥ T e n e m o s   p r o b l e m a s   p a r a   s i n c r o n i z a r   t u   i n f o r m a c i ó n .   E s   p o s i b l e   q u e   e l   s e r v i d o r   t e   p i d a   q u e   s e l e c c i o n e s   u n a   c o n e x i ó n   c i f r a d a   ( S S L )   e n   l a   c o n f i g u r a c i ó n   d e   e s t a   c u e n t a .   { T e n e m o s   p r o b l e m a s   p a r a   s i n c r o n i z a r   e s t a   c u e n t a .   S i   s i g u e   a p a r e c i e n d o   e s t e   e r r o r ,   e l i m i n a   e s t a   c u e n t a   y   v u e l v e   a   a g r e g a r l a .   þ E s   p o s i b l e   q u e   t e n g a s   q u e   e m p e z a r   a   u s a r   e l   c o r r e o ,   l o s   c o n t a c t o s   y   e l   c a l e n d a r i o   e n   t u   P C   a n t e s   d e   p o d e r   s i n c r o n i z a r   e s t a   i n f o r m a c i ó n   c o n   t u   d i s p o s i t i v o .   S i   e l   p r o b l e m a   c o n t i n ú a ,   p o n t e   e n   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   o   c o n   e l   p r o v e e d o r   d e   s e r v i c i o s .   0 E l   u s u a r i o   n o   e s t á   a u t o r i z a d o   p a r a   s i n c r o n i z a r .   î N o   p o d e m o s   a g r e g a r   e s t a   c u e n t a   a   t u   d i s p o s i t i v o   p o r q u e   y a   l a   c o n f i g u r a s t e   e n   e l   n ú m e r o   m á x i m o   d e   d i s p o s i t i v o s .  
  
 P u e d e s   i n t e n t a r   q u i t a r   d i s p o s i t i v o s   d e   l a   c u e n t a   e n   I n t e r n e t ,   o   b i e n   p o n t e   e n   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   d e   t u   c u e n t a .     h % 1 ! s !   n o   p e r m i t i ó   q u e   r e s p o n d i e r a s   a   e s t e   m e n s a j e .   V u e l v e   a   i n t e n t a r l o   m á s   t a r d e   o   e n v í a l o   d e s d e   t u   P C .   d % 1 ! s !   t u v o   u n   p r o b l e m a   a l   e n v i a r   e s t e   m e n s a j e .   V u e l v e   a   i n t e n t a r l o   m á s   t a r d e   o   e n v í a l o   d e s d e   t u   P C .   U T u   r e s p u e s t a   n o   s e   p u d o   e n v i a r .   V u e l v e   a   i n t e n t a r l o   m á s   t a r d e   o   e n v í a l a   d e s d e   t u   P C .       r N o   e n c o n t r a m o s   e s t e   e l e m e n t o   e n   t u   b u z ó n .   S i n c r o n i z a   l a   c u e n t a   p a r a   a s e g u r a r t e   d e   q u e   e l   e l e m e n t o   t o d a v í a   e x i s t e .                 ´ N o   p u e d e s   e n v i a r   c o r r e o   d e s d e   e s t a   c u e n t a   p o r q u e   p a r e c e   q u e   h a y   u n   p r o b l e m a   c o n   e l   s e r v i d o r .   P a r a   o b t e n e r   m á s   i n f o r m a c i ó n ,   p o n t e   e n   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   d e   t u   s e r v i d o r .   ´ N o   p u e d e s   e n v i a r   c o r r e o   d e s d e   e s t a   c u e n t a   p o r q u e   p a r e c e   q u e   h a y   u n   p r o b l e m a   c o n   e l   s e r v i d o r .   P a r a   o b t e n e r   m á s   i n f o r m a c i ó n ,   p o n t e   e n   c o n t a c t o   c o n   e l   s o p o r t e   t é c n i c o   d e   t u   s e r v i d o r .   y P a r e c e   q u e   e s t a s   d i r e c c i o n e s   d e   c o r r e o   n o   f u n c i o n a n .   C o m p r u e b a   q u e   l a s   d i r e c c i o n e s   s e a n   c o r r e c t a s   y   v u e l v e   a   i n t e n t a r l o .   » N o   p u e d e s   e n  (this.errors.length > 0)
            throw new Error('Document with errors cannot be stringified');
        if ('indent' in options &&
            (!Number.isInteger(options.indent) || Number(options.indent) <= 0)) {
            const s = JSON.stringify(options.indent);
            throw new Error(`"indent" option must be a positive integer, not ${s}`);
        }
        return stringifyDocument(this, options);
    }
}
function assertCollection(contents) {
    if (isCollection(contents))
        return true;
    throw new Error('Expected a YAML collection as document contents');
}

export { Document };
